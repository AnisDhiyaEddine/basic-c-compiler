
ToDo: 
 2- Implement variables support (Semantical analyzer).


09/09/2022 notes: 
 -> Today will be working on loops.
 -> Still have to work on functions.
 -> Code a turing machine support model.
 


loops: for(){}, while(){}, do{}while().

for (E1; E2; E3) I;


E1, 
While (E2){
    I, 
    E3
}

do { I; E1 } while(E2)

Implement a loop node {
    if(!T) break;
    I;
}

Implement a break node;
Implement a third type;
        // I -> while '(' E ')' I;
        // I -> do I while '(' E ');'; 
        // I -> for '(' E ';' E ';' E ) I
        // break;

        // while
        // Node('break'); Node('loop')->Node('cond')->Node(E) -> Node(I);
        //                                                       Node('break');

        // do {} while();
        // Node('loop') -> Node(I) 
        //              -> Node('cond') -> Node('!') -> Node(E)
        //                              -> Node('break');

        // for(Einit, Etest, Enext){};
        // Node('Seq') -> Node('init')
        //             -> Node('loop') -> Node(next)
        //                             -> Node(I)
        //                             -> Node(cond)  -> Node(test)
        //                                            -> Node(break)



Today we will see functions
-> Still have to add dyncamically allocated memory [dyncamic arrays].
-> Structs (won't be added in our compilator) -> arrays are supported because we have the same type inside arrays.
[For non stack machines, registered machines -> another step that is very complicated should be added after the semantical analysis
step].

-> 1st: should add a stack pointer and update it regularly (SP)
-> 2nd: should add a base pointer (BP)
-> stack [BP*, ..... SP*, BP*, @ret, functionCALL, ...] (restore when the function returns).
-> drop() when I finish the evaluation of an expression I -> E ; Ã  checker.
-> In our case we have to make 2 instructions 
[
    prep label_funtion
    call 0 for now 
] This is a function call :);
label_function 
... instructions should end with an RET.
ret;

inside F in the syntacixal analyzer
return type, accept it properly
ident () I instead of ident(){}
ident () I is a prototype when I is just a ; 
useful when 
int A(){
    B();
}
int B(){
    A();
} // this won't be supported in my compiler.

Node(new Token('func', 'valueName'), child_1 = null, child_2 = I); 
=> Function declaration is now supported

=> Function calls: 
-> should be added in A();
-> ident"(" ")" a sepecial case before the creation 


#CodeGEN contract = 
    do not touch what doesn't belong to you
    Leave a single value when you finish
    Do whatever you want on the top :)



==> Pour le debug :) to print(1024) should decompose and transform to ASCII code
I -> Send E     => Node(send) -> E()
A -> recv       => Node(recv)

==> Petite fonction de transformation en code ASCII :).
==> code printf for printing numbers.
==> Next.. runtime concept.
==> Will add a runtime file that contains print, dyncamic_mem managment: malloc, realloc, free.



=> Done: 
 -> tokens generation. (TESTED)
 -> comments, spaces and pre-processors skipping. (TESTED)
 -> mathemathical expressions evaluation. (TESTED)
 -> typed variable declarations (type deduction is not yet supported). (TESTED) .. edge cases should be verified
 -> deeply nested if-else or if expressions. (TESTED)




To be discussed: 
 -> Is it possible to have code outside block ? 
 -> Consts re-affectation => should be easy.
 -> 