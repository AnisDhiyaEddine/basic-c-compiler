
ToDo: 
 2- Implement variables support (Semantical analyzer).


09/09/2022 notes: 
 -> Today will be working on loops.
 -> Still have to work on functions.
 -> Code a turing machine support model.
 


loops: for(){}, while(){}, do{}while().

for (E1; E2; E3) I;


E1, 
While (E2){
    I, 
    E3
}

do { I; E1 } while(E2)

Implement a loop node {
    if(!T) break;
    I;
}

Implement a break node;
Implement a third type;
        // I -> while '(' E ')' I;
        // I -> do I while '(' E ');'; 
        // I -> for '(' E ';' E ';' E ) I
        // break;

        // while
        // Node('break'); Node('loop')->Node('cond')->Node(E) -> Node(I);
        //                                                       Node('break');

        // do {} while();
        // Node('loop') -> Node(I) 
        //              -> Node('cond') -> Node('!') -> Node(E)
        //                              -> Node('break');

        // for(Einit, Etest, Enext){};
        // Node('Seq') -> Node('init')
        //             -> Node('loop') -> Node(next)
        //                             -> Node(I)
        //                             -> Node(cond)  -> Node(test)
        //                                            -> Node(break)



Today we will see functions
-> Still have to add dyncamically allocated memory [dyncamic arrays].
-> Structs (won't be added in our compilator) -> arrays are supported because we have the same type inside arrays.
[For non stack machines, registered machines -> another step that is very complicated should be added after the semantical analysis
step].

-> 1st: should add a stack pointer and update it regularly (SP)
-> 2nd: should add a base pointer (BP)
-> stack [BP*, ..... SP*, BP*, @ret, functionCALL, ...] (restore when the function returns).
-> 
() when I finish the evaluation of an expression I -> E ; à checker.
-> In our case we have to make 2 instructions 
[
    prep label_funtion
    call 0 for now 
] This is a function call :);
label_function 
... instructions should end with an RET.
ret;

inside F in the syntacixal analyzer
return type, accept it properly
ident () I instead of ident(){}
ident () I is a prototype when I is just a ; 
useful when 
int A(){
    B();
}
int B(){
    A();
} // this won't be supported in my compiler.

Node(new Token('func', 'valueName'), child_1 = null, child_2 = I); 
=> Function declaration is now supported

=> Function calls: 
-> should be added in A();
-> ident"(" ")" a sepecial case before the creation 


#CodeGEN contract = 
    do not touch what doesn't belong to you
    Leave a single value when you finish
    Do whatever you want on the top :)



==> Pour le debug :) to print(1024) should decompose and transform to ASCII code
I -> Send E     => Node(send) -> E()
A -> recv       => Node(recv)

==> Petite fonction de transformation en code ASCII :).
==> code printf for printing numbers.
==> Next.. runtime concept.
==> Will add a runtime file that contains print, dyncamic_mem managment: malloc, realloc, free.




[contrat]: 
-> don't modify the bottom of the stack.
-> E() -> should leave a value on the top of the stack
-> I() -> should leave nothing on the top of the stack -> start with dup and dump today.

// next time malloc and free.


=> Done: 
 -> tokens generation. (TESTED)
 -> comments, spaces and pre-processors skipping. (TESTED)
 -> mathemathical expressions evaluation. (TESTED)
 -> typed variable declarations (type deduction is not yet supported). (TESTED) .. edge cases should be verified
 -> deeply nested if-else or if expressions. (TESTED)




To be discussed: 
 -> Is it possible to have code outside block ? 
 -> Consts re-affectation => should be easy.
 -> 


 // Today last session we will check the indexation + arrays + runtime file (print function and other handy stuff).

 -> Indexation: 
 t[3] -> 1st possibilty in S (suffix) or au niveau de l'A same as T(3).
 int toto(int x){

 } => stack: [...., @ret, BP, x, .....]

int T ;
T = malloc(3);
T[1]; 
mem [@adr 1st free, code, Free, stack]; // 64K byte with -m option I get 4Mo else modify a constant in the code :)
// we will take 4k byte for the stack :)

int malloc(int n){
    int p, r; 
    p = 0;
    r = *p; // 1st free case is 1000 for instance
    *p = *p + n; // add n and re-write on the first adress.
    return r; // return adress of allocated space
}

int free(int p){};

------------ [OPTIONAL] ------------
mem: [size, ..., size]

1st allocation the size is useful while freeing the block.
mem: [10, [10 elements], 10, -size, [], -size] sizes positive: already allocated else you can allocate on it :)
free just alter the sign of size :)
check the case before if it's negative delete two coulumns -> fusion and go recursively with this operation and update the sizes :()
To handle the fragmentation, check the best fit instead of the first fit (worst fit)
------------------------------------
For memory allocator
runtime
 malloc, free, setup, print, ...
user
.start 
prep setup
call 0
prep main 
call 0
halt


runtime 
 malloc, free, print(int n) => show it on the console :)
 
 #exemple
 print(n){ // this function should be implemented in c-- :)
    if(n < 10) send n + 48; // works for n from 0 to 9 // debug instruction should be checked :)
    else split and call again print for each char :)
    send 10; // retour à la ligne :)
 }

case 'call': // two instructions to handle params as local variables stack [..., BP, @ret, arg1, arg2, loc1, ....]



// Refactor 
// Handle functions number of arguments passed :)
// Handle function calls with an invalid arguments number